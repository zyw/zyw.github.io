<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring内置事件和自定义事件"><meta name="keywords" content="spring,event"><meta name="author" content="平常心,undefined"><meta name="copyright" content="平常心"><title>Spring内置事件和自定义事件 | 平常心</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring内置事件和自定义事件"><span class="toc-number">1.</span> <span class="toc-text">Spring内置事件和自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件传递对象（ApplicationEvent）"><span class="toc-number">1.1.</span> <span class="toc-text">事件传递对象（ApplicationEvent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件监听（ApplicationListener）"><span class="toc-number">1.2.</span> <span class="toc-text">事件监听（ApplicationListener）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件发布"><span class="toc-number">1.3.</span> <span class="toc-text">事件发布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationEventPublisher"><span class="toc-number">1.3.1.</span> <span class="toc-text">ApplicationEventPublisher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationEventMulticaster"><span class="toc-number">1.3.2.</span> <span class="toc-text">ApplicationEventMulticaster</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义事件"><span class="toc-number">1.4.</span> <span class="toc-text">自定义事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">2.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars1.githubusercontent.com/u/661159?s=460&amp;v=4"></div><div class="author-info__name text-center">平常心</div><div class="author-info__description text-center">Java,前端</div><div class="follow-button"><a href="https://github.com/zyw" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">平常心</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Spring内置事件和自定义事件</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/spring/">spring</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Spring内置事件和自定义事件"><a href="#Spring内置事件和自定义事件" class="headerlink" title="Spring内置事件和自定义事件"></a>Spring内置事件和自定义事件</h2><h3 id="事件传递对象（ApplicationEvent）"><a href="#事件传递对象（ApplicationEvent）" class="headerlink" title="事件传递对象（ApplicationEvent）"></a>事件传递对象（ApplicationEvent）</h3><p><img src="/images/spring-event/ApplicationEnvironmentPreparedEvent.png" alt="ApplicationEnvironmentPreparedEvent"></p>
<p><code>ApplicationEvent</code>是事件接口，继承自<code>EventObject</code>(Java规范要求事件对象都需要继承该类)。</p>
<p>内置事件对象包括两部分：</p>
<ol>
<li><code>ApplicationContextEvent</code>是Spring Framework需要的。</li>
<li><code>SpringApplicationEvent</code>该类在Spring boot包下。</li>
</ol>
<a id="more"></a>
<h3 id="事件监听（ApplicationListener）"><a href="#事件监听（ApplicationListener）" class="headerlink" title="事件监听（ApplicationListener）"></a>事件监听（ApplicationListener）</h3><p><img src="/images/spring-event/MultiServerUserRegistry.png" alt="MultiServerUserRegistry"></p>
<p><code>ApplicationListener</code>是Spring的事件监听接口，实现了jdk中的<code>EventListener</code>，该接口只提供了一个抽象方法<code>void onApplicationEvent(E event)</code>用于处理接收到的事件。</p>
<p>子接口<code>SmartApplicationListener</code>增加了两个抽象方法（<code>supportsEventType</code>，<code>supportsSourceType</code>）并且还继承了<code>Ordered</code>接口提供监听器排序。</p>
<p><code>supportsEventType</code>和<code>supportsSourceType</code>两个方法都是过滤方法返回事件类型和事件源类型是否支持。</p>
<h3 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h3><h4 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h4><p><img src="/images/spring-event/AbstractApplicationContext.png" alt="AbstractApplicationContext"></p>
<p><code>ApplicationEventPublisher</code>事件发布接口，<code>ApplicationContext</code>接口继承了该接口，这也就说明Spring Framework的核心<code>IoC</code>容器都具有发布事件的能力，接口方法在<code>AbstractApplicationContext</code>中实现，来看一下实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Publish the given event to all listeners.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> event the event to publish (may be an &#123;<span class="doctag">@link</span> ApplicationEvent&#125;</span></span><br><span class="line"><span class="comment">* or a payload object to be turned into a &#123;<span class="doctag">@link</span> PayloadApplicationEvent&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> eventType the resolved event type, if known</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Publishing event in "</span> + getDisplayName() + <span class="string">": "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//事件发布委派给ApplicationEventMulticaster类来完成</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出事件发布实际上是委派给<code>ApplicationEventMulticaster</code>实例来做的，下面我们来看<code>ApplicationEventMulticaster</code>。</p>
<h4 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h4><p><img src="/images/spring-event/SimpleApplicationEventMulticaster.png" alt="SimpleApplicationEventMulticaster"></p>
<p><code>ApplicationEventMulticaster</code>接口有一个抽象实现和一个简单实现，通过查看<code>ApplicationEventMulticaster</code>接口规范我们会发现改接口提供注册<code>Listener</code>和通知<code>Listener</code>的接口契约。</p>
<p>Spring内部的事件发布是通过<code>ApplicationEvent#publishEvent</code>再委派给<code>ApplicationEventMulticaster</code>实际去发送事件的。我们来看一下<code>ApplicationEventMulticaster</code>的实现逻辑。</p>
<ol>
<li><p><code>ApplicationEventMulticaster</code>的实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment">     * 如果在IoC容器上下文中不存在以applicationEventMulticaster命名的ApplicationEventMulticaster Bean</span></span><br><span class="line"><span class="comment"> * 就使用新创建一个SimpleApplicationEventMulticaster，并注册到IoC容器中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">                         APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">                         <span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SimpleApplicationEventMulticaster#multicastEvent()</code>的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="comment">//如果Executor如果不为空，那么将调用Executor的execute方法，发起异步通知</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则同步通知</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，只要Executor不为空，通知将异步执行，否则同步执行通知，所以我们可以传递Executor对象让通知异步执行。</p>
<ul>
<li><p>SpringBoot方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulticasterAsyncConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">applicationEventMulticaster</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        SimpleApplicationEventMulticaster multicaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">        multicaster.setTaskExecutor(threadPoolTaskExecutor());</span><br><span class="line">        <span class="keyword">return</span> multicaster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>Spring XML方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 名字必须是applicationEventMulticaster和messageSource是一样的，默认找这个名字的对象 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 名字必须是applicationEventMulticaster，因为AbstractApplicationContext默认找个 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 如果找不到就new一个，但不是异步调用而是同步调用 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"applicationEventMulticaster"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 注入任务执行器 这样就实现了异步调用（缺点是全局的，要么全部异步，要么全部同步（删除这个属性即是同步））  --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"executor"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式有个弊端就是通知要么是全部是同步要么全部是异步，不能根据需要决定是否异步，所以我们使用另一种方式实现通知消息异步。我们会在下一篇<strong>自定义事件</strong>中讲解</p>
</li>
</ul>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>有了Spring的支持我们自定义事件是非常简单的。</p>
<ol>
<li><p>自定义事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEvent</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomEvent</span><span class="params">(T source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义事件监听继承自<code>ApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomEvent customEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"得到事件内容："</span> + customEvent.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义事件监听实现<code>SmartApplicationListener</code></p>
<ul>
<li><code>CustomSmartEventListener1</code> order=1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSmartEventListener1</span> <span class="keyword">implements</span> <span class="title">SmartApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(aClass.getName(),CustomEvent.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(String.class.getName(),aClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收到通知1："</span> + applicationEvent.getSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CustomSmartEventListener2</code> order=2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSmartEventListener2</span> <span class="keyword">implements</span> <span class="title">SmartApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(aClass.getName(),CustomEvent.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(String.class.getName(),aClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收到通知2："</span> + applicationEvent.getSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件发布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    applicationContext.publishEvent(<span class="keyword">new</span> CustomEvent&lt;&gt;(<span class="string">"收到消息了吗？"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">得到事件内容：收到消息了吗？</span><br><span class="line">接收到通知1：收到消息了吗？</span><br><span class="line">接收到通知2：收到消息了吗？</span><br></pre></td></tr></table></figure>
<p>从输出接口可以看到order越小监听器越早被调用。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jinnianshilongnian.iteye.com/blog/1902886" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/1902886</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平常心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.v5cn.cn/2019/01/14/spring-event/">http://blog.v5cn.cn/2019/01/14/spring-event/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.v5cn.cn" target="_blank">平常心</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a><a class="post-meta__tags" href="/tags/event/">event</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/18/使用kubeadm搭建kubernetes集群/"><i class="fa fa-chevron-left">  </i><span>使用kubeadm搭建kubernetes集群</span></a></div><div class="next-post pull-right"><a href="/2019/01/11/document-server安装与配置/"><span>document server安装与配置</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By 平常心</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://blog.v5cn.cn">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>