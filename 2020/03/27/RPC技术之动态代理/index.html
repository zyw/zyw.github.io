<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="RPC技术之动态代理(一)"><meta name="keywords" content=""><meta name="author" content="平常心,undefined"><meta name="copyright" content="平常心"><title>RPC技术之动态代理(一) | 平常心</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK动态代理"><span class="toc-number">2.1.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javassist动态代理"><span class="toc-number">2.2.</span> <span class="toc-text">javassist动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytebuddy动态代理"><span class="toc-number">2.3.</span> <span class="toc-text">bytebuddy动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars1.githubusercontent.com/u/661159?s=460&amp;v=4"></div><div class="author-info__name text-center">平常心</div><div class="author-info__description text-center">Java,前端</div><div class="follow-button"><a href="https://github.com/zyw" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">平常心</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">RPC技术之动态代理(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-27</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在RPC技术栈中最主要包括：</p>
<ol>
<li><strong>网络传输</strong>（大部分RPC框架采用TCP作为底层网络传输协议）。</li>
<li><strong>传输协议</strong>（<code>grpc</code>使用的是<code>HTTP2</code>，<code>dubbo</code>使用自定义的<code>dubbo</code>协议，也可以是<code>Restful</code>协议和HTTP协议，还可以是<code>hessian</code>协议）。</li>
<li><strong>数据编码</strong>（RPC中数据编解码也是重要一环，可以使用像，java自带序列化或者是第三方的，比如：<code>protobuf</code>、<code>json</code>、<code>hessian</code>等）。</li>
<li><strong>动态代理</strong>（动态代理在RPC中的作用是在客户的生成服务接口的代理类，让客户的调用服务端接口像是在操作本地接口一样方便，隐藏底层的编解码和网络传输等）。</li>
</ol>
<p>具备以上四点一个RPC底层就实现完了，为什么说是底层呢，因为一个完整的RPC还要包括服务注册与发现、服务治理、负载均衡、熔断和限流等高级功能。<br><a id="more"></a></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理在RPC当中起到隐藏底层实现细节，让客户端调用服务端接口方法像是在操作本地接口一样方便。说道动态代理我们就来看一下几种动态代理。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是针对接口和实现类的代理，也就是JDK的动态代理只能应用于接口对接口实施代理，代码如下：</p>
<ul>
<li>接口代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理的接口类，InvocationHandler和proxy分开，没有添加泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口实现类（被代理类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被代理类，可以对类进行增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理类，必须继承自InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDelegate</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理接口类型</span></span><br><span class="line">    <span class="keyword">private</span> IHello target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDelegate</span><span class="params">(IHello target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前。。。。。"</span>);</span><br><span class="line">        <span class="comment">//target是被代理的接口实现类，所有需要实现类的对象。如果只是代理，</span></span><br><span class="line">        <span class="comment">// 不发起invoke就不需要接口实现对象。RPC就是这样实现，所以client端不需要指定实现类示例。</span></span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"调用后。。。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello iHello = enhanceHello(<span class="keyword">new</span> RealHello());</span><br><span class="line">        System.out.println(<span class="string">"代理类名称："</span> + iHello.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"代理类实现的接口 "</span> + iHello.getClass().getInterfaces()[<span class="number">0</span>].getName());</span><br><span class="line">        iHello.say(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHello <span class="title">enhanceHello</span><span class="params">(IHello target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(),<span class="keyword">new</span> Class&lt;?&gt;[] &#123;IHello.class&#125;,<span class="keyword">new</span> HelloDelegate(target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javassist动态代理"><a href="#javassist动态代理" class="headerlink" title="javassist动态代理"></a>javassist动态代理</h3><p><code>Javaassist</code> 就是一个用来 处理 Java 字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以去生成一个新的类对象，通过完全手动的方式。<code>Javassist</code>的定位是能够操纵底层字节码，所以使用起来并不简单，要生成动态代理类恐怕是有点复杂了。但好的方面是，通过<code>Javassist</code>生成字节码，不需要通过反射完成方法调用，所以性能肯定是更胜一筹的。在使用中，我们要注意一个问题，通过<code>Javassist</code>生成一个代理类后，此<code>CtClass</code>对象会被冻结起来，不允许再修改；否则，再次生成时会报错。<code>javassist</code>比<code>JDK</code>的动态代理要求要宽泛一下，接口不是必须的。</p>
<ul>
<li>被代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"javassist: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDelegate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDelegate</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Method proceed, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增强前。。。。。"</span>);</span><br><span class="line">        Object result = method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">"增强后。。。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealHello hello = enhanceHello(<span class="keyword">new</span> RealHello());</span><br><span class="line">        hello.say(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhanceHello</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        ProxyFactory proxy = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxy.setSuperclass(RealHello.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HelloDelegate&lt;T&gt; delegate = <span class="keyword">new</span> HelloDelegate&lt;&gt;(target);</span><br><span class="line">            <span class="comment">// create方法传递两个空数组</span></span><br><span class="line">            <span class="comment">// 分别代表构造器的参数类型数组和构造器的参数实例数组</span></span><br><span class="line">            <span class="keyword">return</span> (T)proxy.create(<span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>],delegate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bytebuddy动态代理"><a href="#bytebuddy动态代理" class="headerlink" title="bytebuddy动态代理"></a>bytebuddy动态代理</h3><p><code>Byte Buddy</code>是一个JVM的运行时代码生成器，你可以利用它创建任何类，且不像<code>JDK</code>动态代理那样强制实现一个接口。<code>Byte Buddy</code>还提供了简单的<code>API</code>，便于手工、通过<code>Java Agent</code>，或者在构建期间修改字节码。</p>
<p><code>Java</code>反射<code>API</code>可以做很多和字节码生成器类似的工作，但是它具有以下缺点：</p>
<ol>
<li>相比硬编码的方法调用，使用 反射 <code>API</code> 非常慢</li>
<li>反射 <code>API</code> 能绕过类型安全检查</li>
</ol>
<p>比起JDK动态代理、<code>cglib</code>、<code>Javassist</code>，<code>Byte Buddy</code>在性能上具有优势。</p>
<ul>
<li>被代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托方法调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZYW</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-03-02 22:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectProxy3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        String hello = <span class="keyword">new</span> ByteBuddy()</span><br><span class="line">                .subclass(Source.class)</span><br><span class="line">                .method(ElementMatchers.named(<span class="string">"hello"</span>))</span><br><span class="line">                .intercept(MethodDelegation.to(Target.class))</span><br><span class="line">                .make()</span><br><span class="line">                .load(<span class="keyword">this</span>.getClass().getClassLoader())</span><br><span class="line">                .getLoaded()</span><br><span class="line">                .newInstance()</span><br><span class="line">                .hello(<span class="string">"World1111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result: "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ObjectProxy3().target();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇学习了三种动态代理方法，都各自有他们的优缺点。这些只是动态代理中基础。<strong>下一篇我们讲解动态代理在RPC中的应用</strong>，使用JDK动态代理实现一个最简单的RPC</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平常心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.v5cn.cn/2020/03/27/RPC技术之动态代理/">http://blog.v5cn.cn/2020/03/27/RPC技术之动态代理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.v5cn.cn" target="_blank">平常心</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/01/18/使用kubeadm搭建kubernetes集群/"><span>使用kubeadm搭建kubernetes集群</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By 平常心</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://blog.v5cn.cn">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>